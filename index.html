<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>geoKill</title>
<link rel="icon" type="image/png" href="icon.png">
<style>
body { margin:0; background:#111; font-family:sans-serif; overflow:hidden; }
canvas { display:block; margin:0 auto; background:#222; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let state = 'menu';
let keys = {};
let stage = 1;
const maxStages = 20;
let killsThisStage = 0;
let killsRequired = 5;
let lastEnemySpawn = 0;
let startTime = 0;
let elapsedTime = 0;
let timerRunning = false;
let lastDamageTime = Date.now();

const player = { x:canvas.width/2, y:canvas.height/2, size:60, speed:6, gunAngle:0, hp:100 };
const bullets = [];
const enemyBullets = [];
const enemies = [];
let lastShot = 0;
const playerBulletCooldown = 300;
const enemyDamageCooldown = 500;
let enemyLastDamage = new Map();

const playerImg = new Image(); playerImg.src = 'player.png';
const chaserImg = new Image(); chaserImg.src = 'chaser.png';
const shooterImg = new Image(); shooterImg.src = 'shooter.png';
const logo = new Image(); logo.src = 'logo.png';

let canvasButtons = [];

// --- SETTINGS ---
let settings = { mouseControl: true }; // no localStorage
function saveSettings(){ /* disabled */ }

// --- ENEMY CLASS ---
class Enemy {
  constructor(x, y, type='shooter', hp=50, speed=2){
    this.x = x; this.y = y; this.type = type; this.hp = hp; 
    this.speed = speed;
    this.size = 60;
    this.lastShot = 0;
  }
  update(){
    if(this.type==='chaser'){
      const dx = player.x - this.x;
      const dy = player.y - this.y;
      const dist = Math.hypot(dx,dy);
      if(dist>0){ this.x += dx/dist*this.speed; this.y += dy/dist*this.speed; }
      this.x = Math.max(this.size/2, Math.min(canvas.width-this.size/2, this.x));
      this.y = Math.max(this.size/2, Math.min(canvas.height-this.size/2, this.y));
      if(dist < this.size/2 + player.size/2){
        const last = enemyLastDamage.get(this) || 0;
        if(Date.now() - last > enemyDamageCooldown){
          player.hp -= 20;
          lastDamageTime = Date.now();
          enemyLastDamage.set(this, Date.now());
        }
      }
    } else {
      if(Date.now() - this.lastShot > 500){
        this.lastShot = Date.now();
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx,dy);
        enemyBullets.push({x:this.x, y:this.y, dx:dx/dist*5, dy:dy/dist*5, r:5, damage:25});
      }
    }
  }
  draw(){
    ctx.save();
    ctx.translate(this.x,this.y);
    const dx = player.x - this.x;
    const dy = player.y - this.y;
    const angle = Math.atan2(dy,dx)+Math.PI/2;
    ctx.rotate(angle);
    if(this.type==='chaser'){
      if(chaserImg.complete) ctx.drawImage(chaserImg,-this.size/2,-this.size/2,this.size,this.size);
      else { ctx.fillStyle='red'; ctx.fillRect(-this.size/2,-this.size/2,this.size,this.size);}
    } else {
      if(shooterImg.complete) ctx.drawImage(shooterImg,-this.size/2,-this.size/2,this.size,this.size);
      else { ctx.fillStyle='purple'; ctx.beginPath(); ctx.arc(0,0,this.size/2,0,Math.PI*2); ctx.fill();}
    }
    ctx.restore();
  }
}

// --- SPAWN ENEMY ---
function spawnEnemy(){
  const margin = 50;
  const x = margin + Math.random()*(canvas.width-2*margin);
  const y = margin + Math.random()*(canvas.height-2*margin);
  const type = Math.random()<0.5?'chaser':'shooter';
  const hp = 50 + stage*5;
  const speed = type==='chaser'?2+stage*0.1:0;
  enemies.push(new Enemy(x,y,type,hp,speed));
}

// --- SHOOT ---
function shoot(){
  const now = Date.now();
  if(now-lastShot<playerBulletCooldown) return;
  lastShot = now;
  const dx = Math.cos(player.gunAngle- Math.PI/2)*12;
  const dy = Math.sin(player.gunAngle- Math.PI/2)*12;
  bullets.push({x:player.x,y:player.y,dx,dy,r:6, damage:25});
}

// --- START STAGE ---
function startStage(){
  state='game';
  player.hp = 100;
  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  bullets.length = 0; 
  enemyBullets.length = 0; 
  enemies.length = 0;
  killsThisStage = 0; 
  killsRequired = 5 + stage*2;
  lastEnemySpawn = Date.now();
  startTime = Date.now();
  timerRunning = true;
  lastDamageTime = Date.now();
}

// --- FULLSCREEN ---
function toggleFullscreen(){
  if(!document.fullscreenElement) document.documentElement.requestFullscreen();
  else document.exitFullscreen();
}

// --- UPDATE CANVAS BUTTONS ---
function updateCanvasButtons(){
  canvasButtons = [];
  if(state==='menu'){
    const btnTexts = ['Start','Controls','Bio','Credits','Settings','Fullscreen'];
    btnTexts.forEach((t,i)=>{
      const bw=200,bh=50;
      const bx=(canvas.width-bw)/2;
      const by=canvas.height*0.4+i*70;
      let action;
      if(t==='Start') action = startStage;
      else if(t==='Controls') action = ()=>{state='controls';};
      else if(t==='Credits') action = ()=>{state='credits';};
      else if(t==='Bio') action = ()=>{state='bio';};
      else if(t==='Settings') action = ()=>{state='settings';};
      else if(t==='Fullscreen') action = toggleFullscreen;
      canvasButtons.push({x:bx,y:by,w:bw,h:bh,text:t,action});
    });
  }

  if(state==='pause'){
    const bw1 = 300, bh1 = 60;
    const bx1 = (canvas.width - bw1) / 2;
    const by1 = canvas.height / 2 + 40;
    canvasButtons.push({x: bx1, y: by1, w: bw1, h: bh1, text: 'Resume', action: () => { state = 'game'; }});
    const bw2 = 300, bh2 = 60;
    const bx2 = (canvas.width - bw2) / 2;
    const by2 = by1 + bh1 + 20;
    canvasButtons.push({x: bx2, y: by2, w: bw2, h: bh2, text: 'Return to Menu', action: () => { state = 'menu'; player.hp = 100; timerRunning=false; }});
  }

  if(state==='gameover' || state==='victory'){
    const bw=300,bh=60; const bx=(canvas.width-bw)/2; const by=canvas.height/2+50;
    canvasButtons.push({x:bx,y:by,w:bw,h:bh,text:'Return to Menu',action:()=>{state='menu';player.hp=100; timerRunning=false;}});
  }

  if(state==='controls' || state==='credits' || state==='bio' || state==='settings'){
    const bw=250,bh=60; const bx=(canvas.width-bw)/2; const by=canvas.height*0.8;
    canvasButtons.push({x:bx,y:by,w:bw,h:bh,text:'Back to Menu',action:()=>{state='menu';}});
  }
}

// --- CLICK DETECTION ---
canvas.addEventListener('click', e=>{
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  canvasButtons.forEach(b=>{if(mx>=b.x && mx<=b.x+b.w && my>=b.y && my<=b.y+b.h) b.action();});
});

// --- MOUSE MOVE ---
canvas.addEventListener('mousemove', e=>{
  if(settings.mouseControl){
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    player.gunAngle = Math.atan2(my - player.y, mx - player.x) + Math.PI/2;
  }
});

// --- MOUSE CLICK SHOOT ---
canvas.addEventListener('mousedown', e => {
  if(settings.mouseControl && state === 'game'){
    shoot();
  }
});

// --- UPDATE GAME ---
function update(){
  if(state==='game'){
    let velX=0, velY=0;
    if(keys['w']) velY-=player.speed;
    if(keys['s']) velY+=player.speed;
    if(keys['a']) velX-=player.speed;
    if(keys['d']) velX+=player.speed;
    player.x+=velX; player.y+=velY;
    player.x=Math.max(player.size/2, Math.min(canvas.width-player.size/2, player.x));
    player.y=Math.max(player.size/2, Math.min(canvas.height-player.size/2, player.y));

    if(!settings.mouseControl){
      if(keys['arrowleft']) player.gunAngle-=0.15;
      if(keys['arrowright']) player.gunAngle+=0.15;
    }

    if(keys[' ']) shoot();

    bullets.forEach((b,i)=>{
      b.x+=b.dx; b.y+=b.dy;
      enemies.forEach((e,j)=>{
        if(Math.hypot(b.x-e.x,b.y-e.y)<b.r+e.size/2){
          e.hp-=b.damage;
          bullets.splice(i,1);
          if(e.hp<=0){ enemies.splice(j,1); killsThisStage++; lastDamageTime = Date.now(); }
        }
      });
    });

    enemyBullets.forEach((b,i)=>{
      b.x+=b.dx; b.y+=b.dy;
      if(Math.hypot(b.x-player.x,b.y-player.y)<b.r+player.size/2){
        player.hp-=b.damage || 20;
        enemyBullets.splice(i,1);
        lastDamageTime = Date.now();
      }
    });

    const now = Date.now();
    if(enemies.length < killsRequired && now - lastEnemySpawn > 800){
      spawnEnemy();
      lastEnemySpawn = now;
    }

    enemies.forEach(e=>e.update());

    if(now - lastDamageTime > 10000 && player.hp < 100){
      player.hp += 0.25;
      if(player.hp > 100) player.hp = 100;
    }

    if(killsThisStage>=killsRequired){ 
      stage++; 
      if(stage>maxStages) { state='victory'; timerRunning=false; } 
      else startStage(); 
    }
    if(player.hp<=0) { state='gameover'; timerRunning=false; }
    if(keys['escape']) state='pause';

    if(timerRunning) elapsedTime = now - startTime;
  }
}

// --- DRAW ---
function draw(){
  updateCanvasButtons();
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(state==='menu'){
    ctx.fillStyle='#222'; ctx.fillRect(0,0,canvas.width,canvas.height);
    if(logo.complete){const lw=canvas.width*0.3;const lh=lw*0.35;ctx.drawImage(logo,(canvas.width-lw)/2,canvas.height*0.1,lw,lh);}
    canvasButtons.forEach(b=>{ctx.fillStyle='gray';ctx.fillRect(b.x,b.y,b.w,b.h); ctx.fillStyle='white';ctx.font='25px Arial';ctx.textAlign='center';ctx.textBaseline='middle'; ctx.fillText(b.text,b.x+b.w/2,b.y+b.h/2);});
    return;
  }

  // Controls / Bio / Credits / Settings
  if(state==='controls' || state==='bio' || state==='credits' || state==='settings'){
    ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='white'; ctx.font='30px Arial'; ctx.textAlign='center';
    if(state==='controls') ctx.fillText('Controls', canvas.width/2, 80);
    if(state==='bio') ctx.fillText('Bio', canvas.width/2, 80);
    if(state==='credits') ctx.fillText('Credits', canvas.width/2, 80);
    if(state==='settings') ctx.fillText('Settings', canvas.width/2, 80);
    ctx.font='20px Arial';
    
    if(state==='controls'){
      ctx.fillText('WASD - Move', canvas.width/2, 150);
      ctx.fillText('Arrow Keys/Mouse - Rotate', canvas.width/2, 180);
      ctx.fillText('Space/Left Click - Shoot', canvas.width/2, 210);
      ctx.fillText('Esc - Pause', canvas.width/2, 240);
    }

    if(state==='bio'){
      const entries = [
        {img:playerImg,name:'Player',desc:'You',shoot:'0.3s',damage:'25'},
        {img:chaserImg,name:'Chaser',desc:'Chases you',shoot:'N/A',damage:'20'},
        {img:shooterImg,name:'Shooter',desc:'Shoots at you',shoot:'0.5s',damage:'25'}
      ];
      let startY = 150;
      const spacing = 400;
      entries.forEach((e,i)=>{
        const xPos = canvas.width/2 - spacing + i*spacing;
        if(e.img.complete) ctx.drawImage(e.img, xPos-50, startY, 100, 100);
        ctx.fillStyle='white'; ctx.font='20px Arial';
        ctx.fillText(e.name, xPos, startY + 120);
        ctx.fillText(e.desc, xPos, startY + 140);
        ctx.fillText(`Damage: ${e.damage} | Shoot: ${e.shoot}`, xPos, startY + 160);
      });
    }

    if(state==='credits'){
      ctx.fillText('Made by TheRealOwenJ', canvas.width/2, canvas.height/2);
    }

    if(state==='settings'){
      ctx.fillText('Mouse Control', canvas.width/2, 150);
      ctx.fillText(settings.mouseControl ? 'ON' : 'OFF', canvas.width/2, 180);
      ctx.fillText('Press M to toggle', canvas.width/2, 210);
    }

    canvasButtons.forEach(b=>{ctx.fillStyle='gray';ctx.fillRect(b.x,b.y,b.w,b.h);ctx.fillStyle='white';ctx.fillText(b.text,b.x+b.w/2,b.y+b.h/2);});
    return;
  }

  // Player
  ctx.save();
  ctx.translate(player.x, player.y);
  ctx.rotate(player.gunAngle);
  if(playerImg.complete){ctx.drawImage(playerImg, -player.size/2, -player.size/2, player.size, player.size);}
  else {ctx.fillStyle='cyan'; ctx.fillRect(-player.size/2,-player.size/2,player.size,player.size);}
  ctx.fillStyle='white'; ctx.beginPath();
  ctx.moveTo(0, -player.size/2 - 10); ctx.lineTo(-5, -player.size/2 - 20); ctx.lineTo(5, -player.size/2 - 20); ctx.closePath(); ctx.fill();
  ctx.restore();

  bullets.forEach(b=>{ctx.fillStyle='yellow';ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fill();});
  enemyBullets.forEach(b=>{ctx.fillStyle='orange';ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fill();});
  enemies.forEach(e=>e.draw());

  // HUD
  const hudWidth = 250, hudHeight = 90, hudX = 20, hudY = canvas.height - hudHeight - 20;
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(hudX,hudY,hudWidth,hudHeight);
  ctx.fillStyle='white'; ctx.font='18px Arial'; ctx.textAlign='left';
  ctx.fillText('HP', hudX+10, hudY+25);
  ctx.fillStyle='red'; ctx.fillRect(hudX+50,hudY+10,180*(player.hp/100),20); ctx.strokeStyle='white'; ctx.strokeRect(hudX+50,hudY+10,180,20);
  ctx.fillStyle='white'; ctx.font='16px Arial'; ctx.textAlign='center'; ctx.fillText(`${Math.floor(player.hp)}/100`, hudX+50+180/2,hudY+25);
  ctx.fillStyle='white'; ctx.textAlign='left'; ctx.fillText(`Stage: ${stage}/${maxStages}`, hudX+10,hudY+60);
  ctx.fillText(`Kills: ${killsThisStage}/${killsRequired}`, hudX+120,hudY+60);

  // Timer
  ctx.fillStyle='white'; ctx.font='18px Arial'; ctx.textAlign='right';
  const timer = Math.floor(elapsedTime/1000);
  const minutes = Math.floor(timer/60).toString().padStart(2,'0');
  const seconds = (timer%60).toString().padStart(2,'0');
  ctx.fillText(`Time: ${minutes}:${seconds}`, canvas.width - 20, canvas.height - 20);

  // Overlay
  if(state==='pause'){ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='white'; ctx.font='40px Arial';ctx.textAlign='center';ctx.fillText('PAUSED',canvas.width/2,canvas.height/2);}
  if(state==='gameover'){ctx.fillStyle='red';ctx.font='40px Arial';ctx.textAlign='center';ctx.fillText('Game Over',canvas.width/2,canvas.height/2);}
  if(state==='victory'){ctx.fillStyle='lime';ctx.font='40px Arial';ctx.textAlign='center';ctx.fillText('You Win!',canvas.width/2,canvas.height/2);}
  
  canvasButtons.forEach(b=>{ctx.fillStyle='gray';ctx.fillRect(b.x,b.y,b.w,b.h);ctx.fillStyle='white';ctx.fillText(b.text,b.x+b.w/2,b.y+b.h/2);});
}

// --- LOOP ---
function loop(){ update(); draw(); requestAnimationFrame(loop); }
loop();

// --- INPUT ---
document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(state==='settings' && e.key.toLowerCase()==='m'){ settings.mouseControl = !settings.mouseControl; }
});
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// --- RESIZE ---
window.addEventListener('resize',()=>{ canvas.width=window.innerWidth; canvas.height=window.innerHeight; });
</script>
</body>
</html>
